<?php

include_once('cod_bof.features.inc');

/**
 * Implementation of hook_menu().
 */
function cod_bof_menu() {
  $items['cod-scheduler/%'] = array(
    'title' => 'Schedule a session',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cod_bof_schedule', 1),
    'access arguments' => array('create bof_session content'), // @todo this is wrong
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_theme().
 */
function cod_bof_theme() {
  return array(
    'cod_bof_calendar' => array(
      'arguments' => array('view' => NULL, 'options' => NULL, 'rows' => NULL, 'title' => NULL),
      'template' => 'cod-bof-calendar',
    ),
  );
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function cod_session_form_node_type_form_alter(&$form, $form_state) {
  if (isset($form['#node_type'])) {
    // Provide scheduling exclusvity control for this content type.
    $form['cod_session'] = array(
      '#type' => 'fieldset',
      '#title' => t('COD Exclusivity'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form['cod_session']['cod_exclusive'] = array(
      '#title' => t('Content type is exclusive when scheduled'),
      '#type' => 'checkbox',
      '#default_value' => variable_get('cod_exclusive_' . $form['#node_type']->type, TRUE),
      '#description' => t('No other content can be scheduled in same room and time slot. Scheduling is enabled for this type by adding the room and time slot fields.'),
      // @todo, also make reference to room spanning?
    );
  }
}

/**
 * Implementation of hook_form_alter().
 */
function cod_bof_form_alter(&$form, &$form_state, $form_id) {
  // @todo consider altering user_admin_perm form to disable editing
  // of edit slot and room permissions?
  if ($form_id == 'bof_session_node_form') {
    if (isset($_REQUEST['edit'])) {
      // @todo this is only necessary if room and slot are custom rendered.
      /*$room_nid = $_REQUEST['edit']['field_session_room']['nid']['nid'];
      $slot_nid = $_REQUEST['edit']['field_session_slot']['nid']['nid'];
      // Pass along Prepopulate and destination parameters in case the user
      // chooses to add a new BoF.
      $url_query = array(
        'edit[field_session_room][nid][nid]' => $room_nid,
        'edit[field_session_slot][nid][nid]' => $_REQUEST['edit']['field_session_slot']['nid']['nid'],
        'destination' => $_REQUEST['destination'],
      );
      $room = node_load($room_nid);
      $slot = node_load($slot_nid);
      // Sanity check that bad data wasn't requested.
      if ($slot->type != 'time_slot' || $slot->status != 1 || $room->type != 'room' || $room->status != 1) {
        return;
      }
      $form['room_markup'] = array(
        '#type' => 'markup',
        '#value' => '<div>' . t('<strong>Room</strong>: @room', array('@room' => $room->title)) . '</div>',
      );
      $time_range = cod_session_time_slot_format($slot);
      $form['slot_markup'] = array(
        '#type' => 'markup',
        '#value' => '<div>' . t('<strong>Time</strong>: @start - @end', array('@start' => $time_range['start'], '@end' => $time_range['end'])) . '</div>',
      );*/
      // Hide the CCK rendering of the fields.
      /*$form['field_session_room']['#type'] = TRUE;
      $form['field_session_slot']['#type'] = TRUE;*/
    }
    // Make the room widget a select list.
    $form['field_session_room']['#type'] = 'nodereference_select';
      // Keep the widget from allowing multiple values.
    $form['#field_info']['field_session_room']['multiple'] = FALSE;
    // Redirect after form submission of the schedule.
    $form['#redirect'] = 'program/bof-schedule'; // @todo get this from View?
    // Disable editing of the room and slot fields wuth after_build, FAPI!!!
    //$form['#after_build'][] = '_cod_bof_form_after_build';
    if ($form['#node']->nid) {
      // Provide unschedule checkbox.
      $form['cod_bof_unschedule'] = array(
        '#type' => 'checkbox',
        '#title' => t('Unschedule this BoF'),
        '#weight' => -1000,
      );
      $form['#submit'][] = '_cod_bof_unschedule';
    }
  }
}

/**
 * After build the node add bof form to disable room and slot selection.
 */
function _cod_bof_form_after_build($form, &$form_state) {
  $form['field_session_slot']['nid']['nid']['#attributes']['disabled'] = 'disabled';
  $form['field_session_room']['nid']['nid']['#attributes']['disabled'] = 'disabled';
  return $form;
}

/**
 * Form submit handler for bof node form.
 */
function _cod_bof_unschedule($form, &$form_state) {
  if (!empty($form_state['values']['cod_bof_unschedule'])) {
    // Unset scheduled room and time slot.
    $form_state['values']['field_session_room'][0]['nid'] = NULL;
    $form_state['values']['field_session_slot'][0]['nid'] = NULL;
  }
}

/**
 * Helper function computes time slot range.
 *
 * @param object Time slot node.
 * @return array Array of start and end times.
 */
function cod_session_time_slot_format($slot) {
  static $ranges = array();
  if (!isset($ranges[$slot->nid])) {
    $date_start = date_make_date($slot->field_slot_datetime[0]['value'], $slot->field_slot_datetime[0]['timezone_db']);
    $date_end = date_make_date($slot->field_slot_datetime[0]['value2'], $slot->field_slot_datetime[0]['timezone_db']);
    date_timezone_set($date_start, timezone_open($slot->field_slot_datetime[0]['timezone']));
    date_timezone_set($date_end, timezone_open($slot->field_slot_datetime[0]['timezone']));
    $start = date_format_date($date_start, 'custom', 'g:iA');
    $end = date_format_date($date_end, 'custom', 'g:iA');
    $ranges[$slot->nid] = array('formatted_start' => $start, 'formatted_end' => $end, 'date_start' => $date_start, 'date_end' => $date_end);
  }
  return $ranges[$slot->nid];
}

/**
 * Get BoFs created by a user.
 * @todo rename this off bofs
 * @param boolean $all Whether to return all BoFs or just those unscheduled.
 * @return array Array of BoF nodes or empty.
 */
function cod_bof_users_bofs($account, $type, $all = TRUE) {
  $nids = $bofs = array();

  if ($all) {
    $sql = "SELECT n.nid FROM {node} n WHERE n.type = '%s' AND n.uid = %d AND n.status = 1";
  }
  else {
    $sql = "SELECT n.nid FROM {node} n
    INNER JOIN {content_field_session_room} r
    ON r.nid = n.nid AND r.vid = n.vid
    INNER JOIN {content_field_session_slot} s
    ON s.nid = n.nid AND s.vid = n.vid
    WHERE n.type = '%s' AND n.uid = %d AND n.status = 1
    AND r.field_session_room_nid IS NULL AND s.field_session_slot_nid IS NULL";
  }
  $result = db_query(db_rewrite_sql($sql), $type, $account->uid);
  while ($record = db_fetch_array($result)) {
    $nids[] = $record['nid'];
  }
  if (empty($nids)) {
    return array();
  }
  foreach ($nids as $nid) {
    $bofs[$nid] = node_load($nid);
  }
  return $bofs;
}

/*function cod_bof_schedule($ajax = FALSE) {
  // COD BoF uses Prepopulate so retrieve room and time slot from the request.
  if (isset($_REQUEST['edit'])) {
    $room_nid = $_REQUEST['edit']['field_session_room']['nid']['nid'];
    $slot_nid = $_REQUEST['edit']['field_session_slot']['nid']['nid'];
    // Pass along Prepopulate and destination parameters in case the user
    // chooses to add a new BoF.
    $url_query = array(
      'edit[field_session_room][nid][nid]' => $room_nid,
      'edit[field_session_slot][nid][nid]' => $slot_nid,
    );
    $room = node_load($room_nid);
    $slot = node_load($slot_nid);
    // Sanity check that bad data wasn't passed.
    if ($slot->type != 'time_slot' || $slot->status != 1 || $room->type != 'room' || $room->status != 1) {
      drupal_access_denied();
      return;
    }
  }
  else {
    // No arguments so 404.
    drupal_not_found();
    return;
  }
  
  if (!$ajax) {
    return drupal_get_form('cod_bof_schedule_form', $room, $slot, $url_query);
  }

  $form_state = array(
    'ajax' => TRUE,
    'title' => t('Schedule'),
    'args' => array($room, $slot, $url_query),
  );
  $output = dialog_form_wrapper('cod_bof_schedule_form', $form_state);
  if (empty($output)) {
    $output[] = dialog_command_display(t('Comment submitted'), t('Reloading...'));
    $output[] = ctools_ajax_command_reload();
  }
  ctools_ajax_render($output);
}*/

/**
 * Custom schedule a BoF form.
 */
//function cod_bof_schedule_form(&$form_state, $room, $slot, $url_query) {
function cod_bof_schedule(&$form_state, $type) {
  // @todo, check cod_session_schedule_access().
  global $user;
  $url_query = array();
  // COD BoF uses Prepopulate so retrieve room and time slot from the request.
  if (isset($_REQUEST['edit'])) {
    $room_nid = $_REQUEST['edit']['field_session_room']['nid']['nid'];
    $slot_nid = $_REQUEST['edit']['field_session_slot']['nid']['nid'];
    // Pass along Prepopulate and destination parameters in case the user
    // chooses to add a new BoF.
    $url_query = array(
      'edit[field_session_room][nid][nid]' => $room_nid,
      'edit[field_session_slot][nid][nid]' => $slot_nid,
    );
    $room = node_load($room_nid);
    $slot = node_load($slot_nid);
    // Sanity check that bad data wasn't passed.
    if ($slot->type != 'time_slot' || $slot->status != 1 || $room->type != 'room' || $room->status != 1) {
      drupal_access_denied();
      return;
    }
  }
  else {
    // No arguments so 404.
    drupal_not_found();
    return;
  }

  // Show unscheduled BoFs for this user.
  $bofs = cod_bof_users_bofs($user, $type, FALSE);
  if (empty($bofs)) {
    // Redirect to node add if the user has no BoFs.
    drupal_goto('node/add/bof-session', $url_query);
  }

  foreach ($bofs as $bof) {
    $options[$bof->nid] = check_plain($bof->title);
  }
  $form['bof'] = array(
    '#type' => 'radios',
    '#title' => t('Pick a BoF to schedule'),
    '#options' => $options,
    '#default_value' => array_shift(array_keys($options)),
  );
  $form['add_bof'] = array(
    '#type' => 'markup',
    '#value' => '<div>' . l(t('Add a new BoF'), 'node/add/bof-session', array('query' => $url_query)) . '</div>',
  );

  $time_range = cod_session_time_slot_format($slot);
  $form['chosen'] = array(
    '#type' => 'item',
    '#title' => t('You have chosen'),
    '#value' => t('Room: @room <br/> Time: @start - @end', array('@room' => $room->title, '@start' => $time_range['formatted_start'], '@end' => $time_range['formatted_end']))
  );
  $form['schedule'] = array(
    '#type' => 'value',
    '#value' => array('room' => $room, 'slot' => $slot),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Schedule'),
  );
  $form['#redirect'] = 'program/bof-schedule'; // @todo get this from the View?
  $form['cancel'] = array(
    '#type' => 'markup',
    '#value' => l(t('Cancel'), 'program/bof-schedule'),
  );

  return $form;
}

function cod_bof_schedule_submit($form, $form_state) {
  module_load_include('inc', 'node', 'node.pages');
  $bof = node_load($form_state['values']['bof'], NULL, TRUE);
  $bof->field_session_slot[]['nid'] = $form_state['values']['schedule']['slot']->nid;
  $bof->field_session_room[]['nid'] = $form_state['values']['schedule']['room']->nid;
  $bof = node_submit($bof);
  // @todo get any errors.
  node_save($bof);
}

/**
 * Implementation of hook_nodeapi().
 */
function cod_bof_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($op == 'validate') {
    // If the node has a room and slot field, make sure there are no existing nodes that have the same room/slot combination.
    // Unless the node is not exclusive, then check room capacity.
    if (!empty($node->field_session_slot[0]['nid']) && !empty($node->field_session_room[0]['nid'])) {
      $slots = $rooms = array();
      foreach ($node->field_session_slot as $slot) {
        if (!empty($slot['nid'])) {
          $slots[] = $slot['nid'];
        }
      }
      // Get rooms.
      foreach ($node->field_session_room as $room) {
        if (!empty($room['nid'])) {
          $rooms[$room['nid']] = node_load($room['nid']);
        }
      }
      // Get room capacity if this node is scheduled in only one room.
      // If multiple rooms are selected it should mean this node is exclusive.
      $capacity = 0;
      if (count($rooms) == 1) {
        $room = current($rooms);
        if (isset($room->field_room_session_capacity) && $room->field_room_session_capacity[0]['value']) {
          $capacity = $room->field_room_session_capacity[0]['value'];
        }
      }

      if (!empty($slots) && !empty($rooms)) {
        $room_nids = array_keys($rooms);
        $result = db_rewrite_sql(db_query("SELECT DISTINCT
        node.nid AS nid,
        node.title AS title,
        node.type AS type,
        r.field_session_room_nid AS room_nid,
        node2.title AS room_title
        FROM {node} node
        INNER JOIN {content_field_session_room} r
        ON r.nid = node.nid AND r.vid = node.vid 
        AND r.field_session_room_nid IN (" . db_placeholders($room_nids, 'int') . ")
        INNER JOIN {node} node2
        ON r.field_session_room_nid = node2.nid 
        INNER JOIN {content_field_session_slot} s
        ON s.nid = node.nid AND s.vid = node.vid 
        AND s.field_session_slot_nid IN (" . db_placeholders($slots, 'int') . ")
        WHERE node.nid != %d
        ", array_merge($room_nids, $slots, array($node->nid))));

        $errors = array();
        while ($record = db_fetch_object($result)) {
          $capacity--;
          if ($capacity <= 0 || variable_get('cod_exclusive_' . $record->type, TRUE)) {
            $errors[] = t('!session in !room', array('!session' => l($record->title, 'node/' . $record->nid), '!room' => l($record->room_title, 'node/' . $record->room_nid)));
          }
        }

        if (!empty($errors)) {
          form_set_error('', format_plural(count($errors), 'The proposed slot and room conflicts with the following item:','The proposed slot and rooms conflict with the following items:') . theme('item_list', $errors) . format_plural(count($errors), 'Please select a different slot and/or room.', 'Please select a different slot and/or rooms.'));
        }
      }
    }
  }
}

/**
 * Theme function to render the calendar grid.
 */
function template_preprocess_cod_bof_calendar(&$vars) {
  global $user;
  // $view->result contains the raw data
  // $vars['rows'] contains the row-formatted fields

  $view = $vars['view'];
  // Save raw row View results keyed on nid.
  $view_results = $scheduled_items = $node_types = array();
  if (!empty($view->result)) {
    foreach ($view->result as $key => $view_result) {
      $node = node_load($view_result->nid);
      $scheduled_items[$node->nid] = $node;
      // $view_results will be what is actually output in the tpl file.
      $view_results[$node->nid] = $vars['rows'][$key];
      // Hold onto node types seen in this View.
      if (!in_array($node->type, $node_types)) {
        $node_types[] = $node->type;
      }
    }
  }
dpm($view);
  // Get days of the schedule @todo consider making this a Style setting.
  $schedule_days = $view->cod_schedule_days;

  //$this_day = array_shift(array_keys($session_days));
  if (!empty($view->args[0])) {
    $this_day = $view->args[0];
  }

  // Attach links to the top of the display.
  // @todo only if there are multiple events
  $day_links = array();
  // @todo but display path could be tab local item '/all'
  //$current_path = $view->display[$view->current_display]->display_options['path'];
  /*foreach ($session_days as $day_key => $day) {
    // @todo pass along links with attribute information?
    $day_links[] = l($day, 'program/bof-schedule/' . $day_key);
  }*/

  // Currently, the Track is given by a text optionwidget.
  // Consider revising this to be taxonomy or node reference to simplify the following.
  $session_attrs = array();
  foreach ($node_types as $type) {
    $type_array = content_types($type);
    foreach ($type_array['fields'] as $field) {
      if ($field['type'] == 'text' && in_array($field['widget']['type'], array('optionwidgets_buttons', 'optionwidgets_select', 'optionwidgets_onoff'))) {
        if (!isset($session_attrs[$field['field_name']])) {
          // Allowed values of a field may or may not have machine-readable keys.
          $allowed_values = content_allowed_values($field);
          $session_attrs[$field['field_name']] = array(
            'name' => $field['field_name'],
            'values' => array_values($allowed_values),
            'keys' => array_keys($allowed_values),
            'machine_keys' => _cod_session_machine_keys($field['field_name'], array_keys($allowed_values)),
            );
        }
      }
    }
  }

  // Create text CCK optionwidgets as attributes of sessions for CSS usage.
  // @todo review for sanitization
  if (!empty($session_attrs)) {
    foreach ($scheduled_items as $session_nid => $session) {
      foreach ($session_attrs as $field) {
        // See if field exists for particular session node.
        if (is_array($session->$field['name'])) {
          // Field could have multiple instances.
          foreach ($session->$field['name'] as $instance) {
            // Emtpy values are NULL.
            if (isset($instance['value'])) {
              // Create container if doesn't exist.
              if (!isset($scheduled_items[$session_nid]->cod_session_classes)) {
                $scheduled_items[$session_nid]->cod_session_classes = array();
              }
              $key = array_search($instance['value'], $field['values']);
              if ($key === FALSE) {
                // It's possible we've rewritten the keys.
                $key = array_search($instance['value'], $field['keys']);
                if ($key !== FALSE) {
                  $value = $field['values'][$key];
                }
              }
              else {
                $value = $instance['value'];
              }
              if ($key !== FALSE) {
                // Create class based on field key.
                $scheduled_items[$session_nid]->cod_session_classes[$field['machine_keys'][$key]] = $value;
              }
            }
          }
        }
      }
    }
  }

  // Get a list of rooms. @todo For sessions, use only those rooms. For BoFs, load rooms allowed for BoF usage.
//  $rooms = _cod_session_schedule_rooms($view->cod_schedule_interactive);
  $result = db_query("SELECT node.nid FROM {node} node WHERE node.type = 'room' AND node.status = 1 ORDER BY node.title ASC");
  while ($record = db_fetch_array($result)) {
    $node = node_load($record['nid']);
    if (isset($node->field_room_session_capacity)) {
      $capacity = check_plain($node->field_room_session_capacity[0]['value']);
    }
    else {
      $capacity = 1;
    }
    $rooms[$node->nid] = array(
      'title' => check_plain($node->title),
      'capacity' => $capacity,
      'nid' => $node->nid,
    );
  }
  // Get a list of time slots. The list itself is powered by a View so it's
  // configurable to allow exclusion.
  // The list of sessions is not filtered by this list. A View filter argument should be used for that.
  // @todo this won't allow different Views on the same day to show different time slots (maybe if one was sessions and the other bofs)?
  $time_slots = array();
  foreach ($schedule_days as $day) {
    $time_slots  = array_merge($time_slots, cod_day_time_slots($day));
  }

  if (empty($rooms) || empty($time_slots)) {
    // No rooms or time slots exist so do not continue.
    return;
  }

  // Load each slot. 
  // @todo This could be malperformant. Consider revising such that all slots 
  // are loaded with single query.
  foreach ($time_slots as $slot) {
    $node = node_load($slot->nid);
    $slots[$node->nid] = $node;
  }

  // Create structured grid of scheduled items in format [slot][room][item_nid]
  $used_slots = $item_grid = $used_rooms = $authored = array();
  foreach ($scheduled_items as $item) {
    if (!empty($item->field_session_slot[0]['nid']) && !empty($item->field_session_room[0]['nid'])) {
      if (!empty($item->cod_session_classes)) {
        $class = ' ' . implode(' ', array_keys($item->cod_session_classes));
      }
      else {
        $class = '';
      }
      // Handle sessions in multiple rooms.
      foreach ($item->field_session_room as $room_instance) {
        $item_grid[$item->field_session_slot[0]['nid']][$room_instance['nid']][$item->nid]['session'] = $item;
        $item_grid[$item->field_session_slot[0]['nid']][$room_instance['nid']][$item->nid]['class'] = $class;
        // Record rooms and used slots.
        $used_rooms[$room_instance['nid']][] = $item->field_session_slot[0]['nid'];
      }
      // Create array of populated slots.
      if (!in_array($item->field_session_slot[0]['nid'], $used_slots)) {
        $used_slots[] = $item->field_session_slot[0]['nid'];
      }
    }
    // Record sessions for this user, their call-to-action can use it.
    if ($item->uid == $user->uid) {
      $authored[] = $item->nid;
    }
  }

  // Explicitly discover if there are unschedled sessions by this user if
  // the interactive workflow is enabled.
  if ($view->cod_schedule_interactive) {
    $authored = cod_bof_users_bofs($user, $view->cod_interactive_type, FALSE);
    if (!empty($authored)) {
      $unscheduled_bofs = TRUE;
    }
  }

  // Arrange slots by days.
  // @todo Give plugin options for date formats and text?
  $arranged_slots = array();
  foreach ($slots as $slot) {
    // Make formatted times.
    $time_format = cod_session_time_slot_format($slot);
    $day_key = date_format_date($time_format['date_start'], 'custom', 'Y-m-d');
    $arranged_slots[$day_key][date_format_date($time_format['date_start'], 'custom', DATE_FORMAT_UNIX)] = array(
      'nid' => $slot->nid,
      'start' => $time_format['formatted_start'],
      'end' => $time_format['formatted_end'],
    );
    // Hold onto what slots go with a day_key so the empty rooms for a day can
    // be easily calculated.
    $days_slots[$day_key][] = $slot->nid;
    if (!isset($days[$day_key])) {
      $days[$day_key] = date_format_date($time_format['date_start'], 'custom', 'F jS, Y');
    }
  }

  // Sort the arranged slots.
  cod_session_ksort_recurse($arranged_slots);

  // Limit room list by the ones in use, unless this schedule is interactive.
  
  // Calculate unused rooms in each day.
  $empty_rooms = $show_rooms = array();
  foreach ($rooms as $room_nid => $room) {
    foreach ($days_slots as $day_key => $day_slots) {
      $intersect = array_intersect($used_rooms[$room_nid], $day_slots);
      if (empty($intersect)) {
        // Room not used on this day.
        $empty_rooms[$day_key][$room_nid] = TRUE;
        if ($view->cod_schedule_interactive) {
          $show_rooms[$day_key][$room_nid] = TRUE;
        }
        else {
          $show_rooms[$day_key][$room_nid] = FALSE;
        }
      }
      else {
        // Room is in use, so show it.
        $show_rooms[$day_key][$room_nid] = TRUE;
      }
    }
  }
  

  // @todo get rooms for each day?
  $room_nids = array_keys($rooms);
  // Build schedule array.
  $schedule_grid = array();
  // For each day...
  foreach ($days as $day_key => $day_title) {
    $schedule_grid[$day_key] = array();
    // For each slot...
    foreach ($arranged_slots[$day_key] as $slot_key => $slot) {
      $schedule_grid[$day_key][$slot['nid']] = array();
      // For each room. $room_key is used for determing colspans.
      foreach ($room_nids as $room_key => $room_nid) {
        if (!$view->cod_schedule_interactive && $empty_rooms[$day_key][$room_nid]) {
          continue;
        }
        // Collect sessions and availability and CTA information.
        // The tpl file determines what to print. @todo make that determination here?

        // Store this room's capacity @todo could make it prop of room array.
        $available = $rooms[$room_nid]['capacity'] ? (int) $rooms[$room_nid]['capacity'] : 0;
        // Now at the level of depth of session_grid, that is [slot][room].
        $schedule_grid[$day_key][$slot['nid']][$room_nid]['sessions'] = array();

        // Check $item_grid for if session exists in this slot.
        if (!empty($item_grid[$slot['nid']][$room_nid])) {
          // Record the session(s) in this room and slot.
          // $item_grid[slot][room] is an array of sessions. Store sessions
          // in $schedule_grid at [day][slot][room]['sessions'].
          $schedule_grid[$day_key][$slot['nid']][$room_nid]['sessions'] = $item_grid[$slot['nid']][$room_nid];
          // Count scheduled items.
          $available = $available - count($item_grid[$slot['nid']][$room_nid]);
          if (count($item_grid[$slot['nid']][$room_nid]) == 1) {
            $this_session = current($item_grid[$slot['nid']][$room_nid]);
            // Session and schedule item content overrides capacity.
            if ($this_session['session']->type != 'bof_session') {
              // @todo Perhaps keep Full message from showing?
              $available = 0;
            }
          }
          

          $colspan = 1;
          // If this slot has only one session, calculate colspans in time slot (row).
          // @todo consider if session is in this and not next sequential room?
          if (count($item_grid[$slot['nid']][$room_nid]) == 1) {
            $this_session = array_pop($item_grid[$slot['nid']][$room_nid]);
            // Check for sessions in remaining rooms.
            for ($i = $room_key + 1; $i < count($room_nids); $i++) {
              if (!empty($item_grid[$slot['nid']][$room_nids[$i]]) && count($item_grid[$slot['nid']][$room_nids[$i]]) == 1) {
                $adjacent = array_pop($item_grid[$slot['nid']][$room_nids[$i]]);
                // Check to see if adjacent column matches.
                if ($this_session->nid == $adjacent->nid) {
                  // We'll accommodate for this in the markup.
                  $colspan++;
                  $schedule_grid[$day_key][$slot['nid']][$room_nids[$i]]['spanned'] = TRUE;
                  // Don't process adjacent room when setting schedule grid.
                  unset($item_grid[$slot['nid']][$room_nids[$i]]);
                }
                else {
                  // Adjacent session does not match.
                  break;
                }
              }
              else {
                // Only consider those which are adjacent.
                break;
              }
            }
          }
          // Set colspan.
          $schedule_grid[$day_key][$slot['nid']][$room_nid]['colspan'] = $colspan;
        }

        // Include room availability and call-to-action if this is an interactive 
        // schedule and user is allowed to create and schedule.
        if ($view->cod_schedule_interactive && cod_session_schedule_access($view->cod_interactive_type, $user)) {
          $type_url_str = str_replace('_', '-', $view->cod_interactive_type); // Oh, Drupal.
          if ($available <= 0) {
            $availability = t('Room is full');
          }
          else {
            $availability = format_plural($available, '@count slot available', '@count slots available');
            // There is availability so provide a call-to-action for scheduling.
            $options = array(
              'query' => array(
                // The session room field is unlimited so it would be rendered as
                // checkboxes but because it's being altered by cod_bof set the
                // Prepopulate arguments to what it will be, a select list.
                'edit[field_session_room][nid][nid]' => $room_nid,
                'edit[field_session_slot][nid][nid]' => $slot['nid'],
                // Cannot pass destination here because the drupal_goto() in
                // cod_bof_schedule() will follow it.
              ),
            );
            // If the user has unscheduled BoFs or has not submitted any
            // they are given a link to add and otherwise to schedule.
            // @todo, get the content type name.
            if (!$authored || !$unscheduled_bofs) {
              $cta = l(t('Add a session'), 'node/add/' . $type_url_str, $options);
            }
            else {
              $cta = l(t('Schedule a session'), 'cod-scheduler/' . $view->cod_interactive_type, $options);
            }
            $schedule_grid[$day_key][$slot['nid']][$room_nid]['cta'] = $cta;
          }
          // Include availability.
          $schedule_grid[$day_key][$slot['nid']][$room_nid]['availability'] = $availability;
        }
      }
    }
  }

  $vars['view_results'] = $view_results;
  $vars['session_grid'] = $item_grid;
  $vars['arranged_slots'] = $arranged_slots;
  $vars['schedule_grid'] = $schedule_grid;
  $vars['days'] = $days;
  //$vars['day_links'] = $day_links;
  $vars['rooms'] = $rooms;
  $vars['room_nids'] = $room_nids;
  $vars['show_rooms'] = $show_rooms;
  $vars['bof'] = $view->bof;
}

function cod_session_days() {
  //static $days = array();
  //if (empty($days)) {
    $sql = "SELECT DATE_FORMAT(s.field_slot_datetime_value, '%s') AS day FROM {content_type_time_slot} s
    INNER JOIN {node} n ON s.nid = n.nid AND s.vid = n.vid
    GROUP BY DATE_FORMAT(s.field_slot_datetime_value, '%s')
    ORDER BY s.field_slot_datetime_value ASC";
    $result = db_query(db_rewrite_sql($sql), '%Y-%m-%d', '%Y-%m-%d');
    while ($record = db_fetch_array($result)) {
      $date = date_make_date($record['day'], NULL, DATE_DATETIME, array('year', 'month', 'day'));
      $days[$record['day']] = date_format_date($date, 'custom', 'F, d Y');
    }
  //}
  return $days;
}

/**
 * Helper function returns a list of rooms to display on the schedule.
 */
function _cod_session_schedule_rooms() {
  $rooms = array();
  // Try and load the schedule room list view.
  $view = views_get_view('schedule_room_list');
  if (!$view) {
    // It didn't load so default to the list of published rooms.
    $result = db_query("SELECT node.nid, node.title FROM {node} node WHERE node.type = 'room' AND node.status = 1 ORDER BY node.title ASC");
    while ($record = db_fetch_object($result)) {
      $room = node_load($result->nid);
      $sponsor = '';
      if (isset($room->field_room_sponsor) && !empty($room->field_room_sponsor[0]['value'])) {
        $sponsor = check_plain($room->field_room_sponsor[0]['value']);
      }
      $rooms[$record->nid] = array(
        'title' => check_plain($record->title),
        'sponsor' => $sponsor,
      );
    }
  }
  else {
    // Return the results from the view.
    $view->execute();
    foreach ($view->result as $record) {
      $rooms[$record->nid] = array(
        'title' => check_plain($record->node_title),
        'sponsor' => check_plain($record->node_data_field_room_sponsor_field_room_sponsor_value),
      );
    }
  }
  return $rooms;
}

/**
 * Get time slots for a day.
 */
function cod_day_time_slots($day = NULL) {
  $time_slots = array();
  $view = views_get_view('cod_time_slots');

  if (!$view) {
    $sql = "SELECT n.nid FROM {node} n
      INNER JOIN {content_type_time_slot} s ON n.nid = s.nid AND n.vid = s.vid
      WHERE n.type = 'time_slot' AND n.status = 1 AND DATE_FORMAT(s.field_slot_datetime_value, '%Y-%m-%d') = '%s'
      ORDER BY s.field_slot_datetime_value ASC";
    $result = db_query(db_rewrite_sql($sql), $day);
    while ($record = db_fetch_object($result)) {
      $time_slots[] = $record;
    }
  }
  else {
    if ($day) {
      $view->args[0] = $day;
    }
    $view->execute();
    $time_slots = $view->result;
  }
  return $time_slots;
}